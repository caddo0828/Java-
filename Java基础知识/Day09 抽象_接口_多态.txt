this:  封装 ，对数据进行初始化，，访问本类的内容
super：访问父类的构造函数，访问父类的东西



当变量同名时， 输出局部变量，输出成员变量用this
 *打印父类成员变量用super
 *this：代表本类中的使用
 *super：代表父类存储空间的标识（可以理解为父类引用，操作父类成员）
 *
 *A：调用成员变量
 *   this.成员变量   调用本类
 *   super.成员变量   调用父类
 * B:调用构造方法：
 *   this(...) 调用本类的构造方法
 *   super(...) 调用父类的构造方法
 * C:调用成员方法：
 *    this.方法名   
 *    super.方法名 



final 标记的类不能被继承
final标注的变量是常量。值不可以被改动
final 修饰的方法不能被重写
final修饰的对象，只能改变对象的内容，不能改变对象的地址值（即就是对象的名字）


多态：同一个对象在不同时期不同的状态
（进行方法的重写）
 向上转型: 父 对象 = new 子类（）；
成员变量：编译看左边，结果看左边
构造方法：只跟类有关，默认父类的构造
成员方法：编译看左边，结果看右边

向下转型： 子类  对象名 = （子类） 父类对象；

接口：
interface 标记
用implements 实现
接口中的变量只能是常量，就算没有表明，系统也默认是常量
接口中的方法只能被定义成抽象方法，无具体的语句块，无其他的成员方法
接口中无构造方法

类与类：继承关系
类和接口：实现关系，类实现接口中的其他辅助功能，类中是具体存在的共性
接口和接口：继承关系


抽象类：abstract关键字
成员变量：既可以是常量也可以是变量
构造方法：可以无参也可以有参
成员方法：可以抽象也可以非抽象，，，抽象方法中没有实体

抽象类不能实例化：
抽象类可以没有抽象方法，但是抽象方法的类一定是抽象类
抽象类的子类：
	是一个具体类：必须重写抽象类的抽象方法
	是一个抽象类：


static： 可以标识一个共有的特征变量
            可以对象引用，也可以类名进行引用


   
