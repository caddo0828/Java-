一、Set集合
要求：一个不包含重复元素的 collection(不允许重复出现相同的元素)
	无序（元素进行存储和取出的顺序不一样）
	元素唯一性

二、HashSet ：存储数据是无序并且唯一的
问题：为什么存储字符串内容时只存储了一个呢？
通过查看add方法的源码，我们知道这个方法实际上是利用了hashCode( ) 和 equals（）方法
步骤;
	首先比较哈希值
	如果相同，比较地址值或者用equals（）方法
	如果不同，就添加到集合中
按照方法步骤来说：
	A：先看hashCode( )值是否相同
		相同;  用equals方法比较
			返回true : 代表元素重复，不添加
			返回false: 添加到集合
		不同：直接添加到集合
/-------如果自定义的类没有重写这两个方法，默认使用Object类的方法（比较不出是否相同）
为什么String可以进行方法的使用？
因为String重写了方法


三、LinkedHashSet :  底层数据结构由哈希表和链表组成
哈希表保证元素的唯一性
链表保证元素有序（存储和取出顺序相同 ）
	

四、哈希表：一种有算法计算出来的哈希值 （相当于新华字典查找元素）


五、TreeSet : 能够对元素按照某种规则进行排序   
特点： 元素排序且唯一
排序两种方式：
	A：自然排序  （实现Comparable接口就是自然排序）   构造方法默认使用自然排序
	// 通过源码可知，add( )方法里最终排序调用的是compareTo( )方法
	//真正的比较依赖的于元素的compareTo（）方法，而这个方法是定义在Comparable接口里的
	//所以如果要重写该方法，就必须实现Comparable接口，这个接口表示的就是自然排序
		
	B：比较器排序
	 有参构造：
		TreeSet(Comparator<? super E> c);
         		 构造一个新的空 set，该 set 根据指定的比较器进行排序。
	1、@@ (Comparator<? super E> c代表的是接口实现类的父类或者本身
	     其实就是定义了一个实现Comparable接口的类，对这个类进行创建对象
	2、格式为
		TreeSet<Student> set = new TreeSet<Student>(new Comparable接口的实现类)；
		此时应该在接口实现类中重写接口里的compare（）方法

@@@@@@ 注意：如果一个方法的参数是接口，其实要的是接口的实现类对象
		匿名内部类可以实现该操作
		

六、TreeSet ：底层是二叉树结构（红黑树是一种自平衡的二叉树）
元素如何存储进去？
	1、第一个元素作为根节点进行存储
	2、从第二个元素开始，每个元素都和根节点进行比较
		大	就作为右孩子
		小	就作为左孩子
		相等	就不添加
元素如何取出？（前序遍历，中序遍历，后序遍历）
前序遍历： 
    1.访问根节点 
    2.前序遍历左子树 
    3.前序遍历右子树 
中序遍历： 
    1.中序遍历左子树 
    2.访问根节点 
    3.中序遍历右子树 
后序遍历： 
    1.后序遍历左子树 
    2.后序遍历右子树 
    3.访问根节点

七、TreeSet集合保证元素排序唯一的原理
唯一性：是根据比较返回的0来决定的
排序：
	A：自然排序;(元素具备比较性)
		 让元素所属的类去实现自然排序接口Comparable
	B：比较器排序;(集合具备比较性)
		让集合构造方法接收一个比较器接口的子类对象Comparator